JVM stands for Java Virtual Machine. It can not only interpret bytecode produced by Java compiler, it can also interpret bytecode produced by other languages like Scala, Kotlin etc.

JVM is a multi threaded machine.

JIT Compiler - JIT stands for Just In Time Compiler. When JVM is running application, it is executing bytecode generated after executing javac command which convert source code to bytecode. JIT used to convert bytecode into native machine code. JIT only convert that part of bytecode into native machine code which is being used very frequently. It can be any part of bytecode that is being invocated frequently. 

Why JIT converts frequently executed bytecode to native machine code?
JIT only converts frequently executed bytecode to native machine code to improve performance of application. Because native machine code is run by operating system at much greater speed in comparison of bytecode. 

Does JIT compilation slows JVM execution?
No, JIT compilation doesn't slow JVM execution as JVM is a multi-threaded virtual machine and separate thread is responsible for JIT compilation.

Are native machine codes generated by JIT same for every operating system like Windows, Mac etc?
No. Native machine codes generated by JIT are not same. It is different for each type of operating system. For Windows, it is different and for Mac, it will be different and so on.

Why JIT compiler not convert whole bytecode into native machine code to increase overall performance of java application?
Because JIT compilation takes time and with CI/CD builds and bug fixes takes place very frequently so JIT compilation is not preferred.